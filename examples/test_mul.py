# amaranth: UnusedElaboratable=no
"""Basic test of amaranth sim pytest plugin using a dummy multiplier."""

import pytest
from amaranth import Elaboratable, Signal, Module
from dataclasses import dataclass
from contextlib import nullcontext as does_not_raise


class Mul(Elaboratable):
    """Dummy Amaranth multiplier module."""

    def __init__(self, width=4, registered=True):
        self.width = width
        self.registered = registered
        self.a = Signal(width)
        self.b = Signal(width)
        self.o = Signal(2*width)

    def elaborate(self, plat):  # noqa: D102
        m = Module()

        if self.registered:
            m.d.sync += self.o.eq(self.a * self.b)
        else:
            m.d.comb += self.o.eq(self.a * self.b)

        return m


@dataclass
class MulTbArgs:
    """Dataclass to collect arguments to the multipler testbench."""

    a_in: int = 1
    b_in: int = 2
    o_out: int = 2


def mul_tb_id(args):
    """Name the multiplier testbench part of a parametric test id."""
    if isinstance(args, MulTbArgs):
        return f"{args.a_in}-{args.b_in}"


def case_ids(args):
    """Create nicer testbench names."""
    if isinstance(args, MulTbArgs):
        return mul_tb_id(args)
    elif isinstance(args, does_not_raise):
        return "pass"
    elif isinstance(args, type(pytest.raises(AssertionError))):
        return "fail"
    else:
        return None


@pytest.fixture(params=[pytest.param(MulTbArgs())], ids=mul_tb_id)
def mul_tb(mod, request):
    """The multiplier testbench proper. Receives arguments via request."""  # noqa: D401, E501
    async def testbench(sim):
        s = sim
        m = mod

        if m.registered:
            await s.tick()
        else:
            await s.delay(0.1)

        s.set(m.a, request.param.a_in)
        s.set(m.b, request.param.b_in)

        if m.registered:
            await s.tick()
        else:
            await s.delay(0.1)

        assert s.get(m.o) == request.param.o_out

    return testbench


@pytest.mark.parametrize("mod,clks", [(Mul(), 1.0 / 12e6)])
def test_basic(sim, mul_tb):
    """Test that multiplication works."""
    sim.run(testbenches=[mul_tb])


# Example of setting ID directly.
@pytest.mark.parametrize(
    "mod,clks,mul_tb", [
        pytest.param(Mul(), 1.0 / 12e6, MulTbArgs(a_in=2, o_out=4),
                     id="alt-mul")
    ], indirect=["mul_tb"])
def test_alternate_inputs(sim, mul_tb):
    """Test that a different multiplication works."""
    sim.run(testbenches=[mul_tb])


@pytest.mark.parametrize(
    "mod,clks,expectation", [
        (Mul(width=1), 1.0 / 12e6, pytest.raises(AssertionError)),
        (Mul(width=6), 1.0 / 12e6,  does_not_raise())
    ], ids=case_ids)
def test_alternate_width(sim, mul_tb, expectation):
    """Given the testbench values, check different multiplier widths."""
    with expectation:
        sim.run(testbenches=[mul_tb])


@pytest.mark.parametrize(
    "mod,clks,mul_tb", [
        (Mul(width=1), 1.0 / 12e6, MulTbArgs(b_in=1, o_out=1)),
        (Mul(width=6), 1.0 / 12e6, MulTbArgs(a_in=16, b_in=16, o_out=256))
    ], indirect=["mul_tb"], ids=case_ids)
def test_alternate_width_and_inputs(sim, mul_tb):
    """Combine testing different testbench values and multiplier widths."""
    sim.run(testbenches=[mul_tb])


@pytest.mark.parametrize(
    "mod,expectation", [
        pytest.param(Mul(registered=True), does_not_raise(),
                     marks=pytest.mark.skip(reason="infinitely loops"),
                     id="reg-mul"),
        (Mul(registered=False), does_not_raise())
    ], ids=case_ids)
# This is the default, though by specifying it, pytest will add "comb" to
# the autogenerated name.
@pytest.mark.parametrize("clks", [None])
def test_comb_tb(sim, mul_tb, expectation):
    """Test that we can do an unregistered/combinational multiply."""
    with expectation:
        sim.run(testbenches=[mul_tb])
